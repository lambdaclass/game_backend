<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Architecture</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../configuration/effects.html"><strong aria-hidden="true">1.</strong> Effects</a></li><li class="chapter-item expanded "><a href="../configuration/loots.html"><strong aria-hidden="true">2.</strong> Loots</a></li><li class="chapter-item expanded "><a href="../configuration/projectiles.html"><strong aria-hidden="true">3.</strong> Projectiles</a></li><li class="chapter-item expanded "><a href="../configuration/skills.html"><strong aria-hidden="true">4.</strong> Skills</a></li><li class="chapter-item expanded "><a href="../configuration/characters.html"><strong aria-hidden="true">5.</strong> Characters</a></li><li class="chapter-item expanded "><a href="../configuration/game.html"><strong aria-hidden="true">6.</strong> Game</a></li><li class="chapter-item expanded "><a href="../attributes/players.html"><strong aria-hidden="true">7.</strong> Player attributes</a></li><li class="chapter-item expanded "><a href="../attributes/projectiles.html"><strong aria-hidden="true">8.</strong> Projectile attributes</a></li><li class="chapter-item expanded "><a href="../architecture/backend_architecture.html" class="active"><strong aria-hidden="true">9.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="../metrics_and_monitoring/metrics-and-monitoring.html"><strong aria-hidden="true">10.</strong> Metrics and monitoring</a></li><li class="chapter-item expanded "><a href="../testing/load_testing/load_testing.html"><strong aria-hidden="true">11.</strong> Load Testing</a></li><li class="chapter-item expanded "><a href="../testing/simulating_latency.html"><strong aria-hidden="true">12.</strong> Simulating High Latency</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="backend-architecture"><a class="header" href="#backend-architecture">Backend Architecture</a></h1>
<p>In this document we go over how the backend is structured. Currently, it serves two related but distinct purposes:</p>
<ul>
<li>It provides a matchmaking functionality, where players join lobbies with other players hoping to start a game or create their own so others can join.</li>
<li>Once a game starts, it acts as the authoritative server for it. It receives players' actions, updates the game state according to the rules of the game, then sends it back to players. We'll call this the <em>gameplay</em> functionality.</li>
</ul>
<p>Having a p2p solution is not possible due to potential cheats and due to connectivity problems between cellphones.
The server is responsible of coordinating state between clients and banning cheaters.</p>
<p>The architecture of the server should be as simple as possible. </p>
<ul>
<li>1 process per player</li>
<li>1 game_state process</li>
<li>N+1 processes in total with N being the number of players</li>
</ul>
<h2 id="round"><a class="header" href="#round">Round</a></h2>
<ol>
<li>Clients send messages to the <code>game_state</code> process</li>
<li>Game state processes all messages in order</li>
<li>The <code>tick</code>, which is the clock of the game, is updated and the game state process sends a small delta update to all the players with the changes that were realized during the tick.</li>
</ol>
<blockquote>
<p>Most of the work is done during 3 where collision is detected, powers get consumed, creates get spawned or assigned to a client, damage and death are resolved.</p>
</blockquote>
<ol start="4">
<li>Go to 1.</li>
</ol>
<h2 id="api"><a class="header" href="#api">API</a></h2>
<p>We aim for the API provided to clients during a game to be as simple as possible:</p>
<ul>
<li>move(joystick_values): Allows a player to move through the board by providing joystick values corresponding to the direction of movement.</li>
<li>basic_attack(joystick_values): Takes joystick values to determine the direction of the attack.</li>
<li>skill(skill_name, joystick_values): Accepts joystick values for skill direction along with the skill name.</li>
<li>refresh: Used to request the entire game state.</li>
</ul>
<p>Additionally, the server can communicate various messages to the clients:</p>
<ul>
<li>game_start: Indicates the start of the game.</li>
<li>game_end: Signals the end of the game.</li>
<li>state: Represents the differences between two states.</li>
<li>game_state: Contains all the information about the game.</li>
<li>ping: Used to inquire about the server's ping.</li>
</ul>
<h2 id="matchmaking"><a class="header" href="#matchmaking">Matchmaking</a></h2>
<p>For matchmaking to work, players should be able to:</p>
<ul>
<li>Join an existing lobby.</li>
<li>Create a lobby if no other exists.</li>
<li>Start the game once the lobby is full.</li>
</ul>
<p>All matchmaking sessions are spawned by a <code>DynamicSupervisor</code> called <code>MatchingSupervisor</code>. When a player creates a lobby, this supervisor starts a new child <code>MatchingSession</code> process. This is the process that will both handle the logic and hold all of the state for that lobby. Right now, that's just a list of the current players in the lobby, along with the ability to add/remove players and start the game.</p>
<p>Inside a lobby, when the game starts, the lobby process uses <a href="https://hexdocs.pm/phoenix_pubsub/Phoenix.PubSub.html">Phoenix PubSub</a> to broadcast a message saying that the game has started; then it terminates. We'll go into it later, but the idea is that the <em>gameplay</em> part of the server will pick up this message and start the game from there.</p>
<p>Every lobby has a unique <code>ID</code>, which we call the <code>session_id</code> throughout the code. This id is simply the erlang <code>PID</code> of the lobby process with an encoding on top to make it human readable. This way players can pass it around to their friends to join their lobbies.</p>
<h3 id="create-lobby"><a class="header" href="#create-lobby">Create lobby</a></h3>
<pre><code class="language-mermaid">sequenceDiagram
    participant Player1
    participant Server
    participant MatchingSupervisor
    participant MatchingSession
    Player1-&gt;&gt;Server: Create lobby
    Server-&gt;&gt;MatchingSupervisor: Create matchmaking session
    MatchingSupervisor-&gt;&gt;MatchingSession: Start child
    MatchingSession-&gt;&gt;MatchingSupervisor: PID
    MatchingSupervisor-&gt;&gt;Player1: Session ID (Encoded PID)
</code></pre>
<h3 id="join-game"><a class="header" href="#join-game">Join game</a></h3>
<pre><code class="language-mermaid">sequenceDiagram
    participant Player2
    participant Server
    participant MatchingSupervisor
    participant MatchingSession
    Player2-&gt;&gt;Server: List lobbies
    Server-&gt;&gt;MatchingSupervisor: list_session_ids()
    MatchingSupervisor-&gt;&gt;Player2: [TKSvPBC9iiXaKrqxigozgYLja71X2s9txQPPqDznj, ...]
    Player2-&gt;&gt;Server: Join Lobby TKSvPBC9iiXaKrqxigozgYLja71X2s9txQPPqDznj
    Server-&gt;&gt;MatchingSession: call(matchmaking_session_pid, :add_player, player)
    MatchingSession-&gt;&gt;Server: OK
    Server-&gt;&gt;Player2: Lobby joined
</code></pre>
<h3 id="start-game"><a class="header" href="#start-game">Start game</a></h3>
<pre><code class="language-mermaid">sequenceDiagram
    Player1-&gt;&gt;Server: Start game TKSvPBC9iiXaKrqxigozgYLja71X2s9txQPPqDznj
    Server-&gt;&gt;MatchingSession: call(matchmaking_session_pid, :start_game)
    MatchingSession-&gt;&gt;MatchingSession: Broadcast {:game_started, matchmaking_session_id, players}
    MatchingSession-&gt;&gt;MatchingSession: Terminate
</code></pre>
<h2 id="gameplay"><a class="header" href="#gameplay">Gameplay</a></h2>
<p>When a game starts, two things happen:</p>
<ul>
<li>A game session is spawned by a <code>DynamicSupervisor</code> called <code>Engine</code>.  This <code>Engine</code> starts a new child <code>Runner</code> process, which holds the entire game's state and the logic to update it according to the players' actions. The PID of this <code>Runner</code> is encoded in a human friendly format and called the <code>game_session_id</code>.</li>
<li>Every player connects to the game through websocket under the <code>/play/:game_session_id</code> path. Each player's connection is handled by a separate <a href="https://ninenines.eu/docs/en/cowboy/2.6/manual/cowboy_websocket/">cowboy websocket</a> process, defined in the <code>PlayWebSocket</code> module. On startup, the process saves the runner's PID so it can communicate with it. Inside the game, a player is the same as a websocket connection.</li>
</ul>
<p>Let's go over the main gameplay flow. Let's say <code>player_1</code> wants to move to the right one square. To do this, they send a <code>JSON</code> frame over the socket that looks like this:</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;move_with_joystick&quot;, &quot;value&quot;: &quot;{angle}&quot;}
</code></pre>
<p>The corresponding <code>PlayWebSocket</code> process picks it up, decodes it, then sends a message to the <code>Runner</code> with the player's action like this:</p>
<pre><code class="language-elixir">GenServer.cast(runner_pid, {:move, user_id, action})
</code></pre>
<p>The <code>Runner</code>'s appropriate handler eventually picks up this message, which in this case looks like this:</p>
<pre><code class="language-elixir">  def handle_cast({:move, user_id, %ActionOk{value: value, timestamp: timestamp}}, state) do
    angle =
      case Nx.atan2(value.y, value.x) |&gt; Nx.multiply(Nx.divide(180.0, Nx.Constants.pi())) |&gt; Nx.to_number() do
        pos_degree when pos_degree &gt;= 0 -&gt; pos_degree
        neg_degree -&gt; neg_degree + 360
      end

    player_id = state.user_to_player[user_id]
    game_state = LambdaGameEngine.move_player(state.game_state, player_id, angle)

    state =
      Map.put(state, :game_state, game_state)
      |&gt; put_in([:player_timestamps, player_id], timestamp)

    {:noreply, state}
  end
</code></pre>
<p>Every action handler updates the game state accordingly. We're managing game
updates through a tick rate. The runner sends a message to itself every 30ms and
does a broadcast of the new state. Currently, this is being done on the handler
that matches with <code>:update_state</code>.</p>
<p>You'll notice the <code>init</code> function on the <code>PlayWebSocket</code> process does (among other things) the following:</p>
<pre><code class="language-elixir">:ok = Phoenix.PubSub.subscribe(DarkWorldsServer.PubSub, &quot;game_play_#{game_id}&quot;)
</code></pre>
<p>This allows the socket processes to receive state updates they can then relay to the player.</p>
<p>Below are two diagrams summarizing the whole flow.</p>
<h3 id="new-game"><a class="header" href="#new-game">New Game</a></h3>
<pre><code class="language-mermaid">sequenceDiagram
    participant Player (Unity Client)
    participant Server
    participant Engine
    participant Runner
    participant PlayerWebSocket
    Player (Unity Client)-&gt;&gt;Server: Start Game
    Server-&gt;&gt;Engine: Start Runner
    Engine-&gt;&gt;Runner: Spawn child
    Runner-&gt;&gt;Engine: Runner PID
    Engine-&gt;&gt;Server: PID
    Server-&gt;&gt;Player (Unity Client): game_session_id
    Player (Unity Client)-&gt;&gt;Server: ws://.../play/:game_session_id
    Server-&gt;&gt;PlayerWebSocket: Handle connection
    PlayerWebSocket-&gt;&gt;PlayerWebSocket: PubSub.subscribe( game_session_topic)
</code></pre>
<h3 id="gameplay-1"><a class="header" href="#gameplay-1">Gameplay</a></h3>
<pre><code class="language-mermaid">sequenceDiagram
    participant Player (Unity Client)
    participant PlayerWebSocket
    participant Runner
    Player (Unity Client)-&gt;&gt;PlayerWebSocket: {&quot;action&quot;: &quot;move&quot;, &quot;value&quot;: &quot;right&quot;}
    PlayerWebSocket-&gt;&gt;Runner: cast(runner_pid, {:play, player_id, {:move, :right}})
    Runner-&gt;&gt;Runner: Move player (update internal state)
    Runner-&gt;&gt;PlayerWebSocket: Broadcast(game_session_topic, {:game_update, new_state})
    PlayerWebSocket-&gt;&gt;Player (Unity Client): new_state
</code></pre>
<h1 id="commentsomissions"><a class="header" href="#commentsomissions">Comments/Omissions</a></h1>
<h2 id="state-management-and-rust-nifs"><a class="header" href="#state-management-and-rust-nifs">State management and Rust NIFs</a></h2>
<p>In the architecture walkthrough above, we glossed over how the game state is handled. Currently, it consists of two things:</p>
<ul>
<li>A list of players, each of which has an <code>id</code>, a position, and a health value.</li>
<li>A <code>board</code>, which is just a matrix indicating what each cell on the map contains (whether it's empty, has a player in it, etc).</li>
</ul>
<p>This state is kept inside the <code>Runner</code> process, but <em>state transitions</em> (players moving, attacking, etc) are computed in Rust. To call Rust code from Elixir we use <a href="https://github.com/rusterlium/rustler">Rustler</a>, which allows us to write <code>NIF</code>s; a way to call low level performant code inside the Erlang VM. You can read more about them <a href="https://www.erlang.org/doc/tutorial/nif.html">here</a> and <a href="https://www.erlang.org/doc/man/erl_nif.html">here</a>.</p>
<p>All the Rust game state code is located inside the <code>native/gamestate</code> directory. The functions exposed to Elixir are all in the <code>lib.rs</code> file. Here's the function that we call to move players around the map:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[rustler::nif(schedule = &quot;DirtyCpu&quot;)]
fn move_player(game: GameState, player_id: u64, direction: Direction) -&gt; GameState {
    let mut game_2 = game;
    game_2.move_player(player_id, direction);
    game_2
}
<span class="boring">}
</span></code></pre></pre>
<p>The associated Elixir function is inside the <code>Engine.Game</code> module:</p>
<pre><code class="language-elixir">def move_player(_a, _b, _c), do: :erlang.nif_error(:nif_not_loaded)
</code></pre>
<p>The magic that makes this call Rust underneath is all inside this <code>use</code> declaration</p>
<pre><code class="language-elixir">use Rustler, otp_app: :dark_worlds_server, crate: &quot;gamestate&quot;
</code></pre>
<p>Every Rust Struct has a corresponding Elixir struct that it maps to; calling the Elixir functions is transparent to someone using the API.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../attributes/projectiles.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../metrics_and_monitoring/metrics-and-monitoring.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../attributes/projectiles.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../metrics_and_monitoring/metrics-and-monitoring.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
